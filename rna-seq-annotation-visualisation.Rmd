---
title: "RNA-seq Analysis in R"
subtitle: "Annotation and Visualisation of RNA-seq results"
author: "Stephane Ballereau, Mark Dunning, Oscar Rueda, Ashley Sawle"
date: '`r format(Sys.time(), "Last modified: %d %b %Y")`'
output:
  html_notebook:
    toc: yes
    toc_float: yes
  html_document:
    toc: yes
    toc_float: yes
minutes: 300
layout: page
bibliography: ref.bib
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Original Authors: Belinda Phipson, Anna Trigos, Matt Ritchie, Maria Doyle, Harriet Dashnow, Charity Law**
Based on the course [RNAseq analysis in R](http://combine-australia.github.io/2016-05-11-RNAseq/) delivered on May 11/12th 2016



```{r}
library(edgeR)
load("Robjects/DE.Rdata")
```


## Adding annotation and saving the results

We have a list of significantly differentially expressed genes, but the only annotation we can see is the Entrez Gene ID, which is not very informative. 

```{r}
topTable(fit.cont)
```

We would like to add some annotation information. There are a number of ways to do this. We will demonstrate how to do this using the *org.Mm.eg.db* package.

```{r}
library(org.Mm.eg.db)
```


First we need to decide what information we want. In order to see what we can extract we can run the `columns` function on the annotation database.

- point to different `org.db` packages
- show different keytypes
- maybe small example of one gene

```{r}
columns(org.Mm.eg.db)
```

We also need to identify what type of key we have. Valid names can be retrieved with the `keytypes` function.

```{r}
keytypes(org.Mm.eg.db)
```

```{r}
## Build up the query step-by-step
keys <- c("12992", "13358","20531")
#select(org.Mm.eg.db,)
```



We definitely want gene symbols and perhaps the full gene name. Let's build up our annotation information in a separate data frame using the `select` function.

```{r}
ann <- select(org.Mm.eg.db,keys=rownames(fit.cont),columns=c("ENTREZID","SYMBOL","GENENAME"))
# Have a look at the annotation
ann
```

Let's double check that the `ENTREZID` column matches exactly to our `fit.cont` rownames.

```{r}
table(ann$ENTREZID==rownames(fit.cont))
```

We can slot in the annotation information into the `genes` slot of `fit.cont`. (Please note that if the `select` function returns a 1:many mapping then you can't just append the annotation to the fit object.)

```{r}
fit.cont$genes <- ann
```

Now when we run the `topTable` command, the annotation information should be included in the output.

```{r}
topTable(fit.cont,coef="B.PregVsLac",sort.by="p")
```

To get the full table (i.e. the information for all genes, not just the top 10) we can specify `n="Inf"`.

```{r}
limma.res <- topTable(fit.cont,coef="B.PregVsLac",sort.by="p",n="Inf")
```

We can save the results table using the `write.csv` function, which writes the results out to a csv file, which you can open in excel.

```{r}
write.csv(limma.res,file="B.PregVsLacResults.csv",row.names=FALSE)
```

**A note about deciding how many genes are significant**: In order to decide which genes are differentially expressed, we usually take a cut-off of 0.05 on the adjusted p-value, NOT the raw p-value. This is because we are testing more than 15000 genes, and the chances of finding differentially expressed genes is very high when you do that many tests. Hence we need to control the false discovery rate, which is the adjusted p-value column in the results table. What this means is that if 100 genes are significant at a 5\% false discovery rate, we are willing to accept that 5 will be false positives. Note that the `decideTests` function displays significant genes at 5\% FDR.

### Diagnostic plots after testing for DE

Let's do a few plots to make sure everything looks good and that we haven't made a mistake in the analysis. Genome-wide plots that are useful for checking are MAplots (or MDplots) and volcano plots. There are functions in limma for plotting these with `fit.cont` as input.

```{r,fig.height=5,fig.width=10}
# We want to highlight the significant genes. We can get this from decideTests.
par(mfrow=c(1,2))
plotMD(fit.cont,coef=1,status=summa.fit[,"B.PregVsLac"])

# For the volcano plot we have to specify how many of the top genes to hightlight.
# We can also specify that we want to plot the gene symbol for the highlighted genes.
# let's highlight the top 100 most DE genes
volcanoplot(fit.cont,coef=1,highlight=100,names=fit.cont$genes$SYMBOL)
```

> ## Challenge {.challenge}
>
> Look at the MD plot and volcano plot for the second comparison, `L.PregVsLac`. Change the number of highlighted genes to 200 in the volcano plot.
>

```{r,echo=FALSE,fig.height=5,fig.width=10}
par(mfrow=c(1,2))
plotMD(fit.cont,coef=2,status=summa.fit[,"L.PregVsLac"])
plotMD(fit.cont,coef=2)

volcanoplot(fit.cont,coef=2,highlight=200,names=fit.cont$genes$SYMBOL)
```


Before following up on the DE genes with further lab work, it is recommended to have a look at the expression levels of the individual samples for the genes of interest. We can quickly look at grouped expression using `stripchart`. We can use the normalised log expression values in the voom object (`v$E`).

```{r,fig.width=12,fig.height=5}
library(RColorBrewer)
par(mfrow=c(1,3))
# Let's look at the first gene in the topTable, Wif1, which has a rowname 24117
stripchart(v$E["24117",]~group)
# This plot is ugly, let's make it better
stripchart(v$E["24117",]~group,vertical=TRUE,las=2,cex.axis=0.8,pch=16,col=1:6,method="jitter")
# Let's use nicer colours
nice.col <- brewer.pal(6,name="Dark2")
stripchart(v$E["24117",]~group,vertical=TRUE,las=2,cex.axis=0.8,pch=16,cex=1.3,col=nice.col,method="jitter",ylab="Normalised log2 expression",main="Wif1")
```

Notice anything interesting about the expression of this gene?

> ## Challenge {.challenge}
>
> Take the top gene from the L.PregVsLactate comparison and make a stripchart of grouped expression as above. (Don't forget to change the title of the plot.)
>

**Solution**
```{r,echo=FALSE}
# Soution
topTable(fit.cont,coef=2,sort.by="p")
stripchart(v$E["12992",]~group,vertical=TRUE,las=2,cex.axis=0.8,pch=16,cex=1.3,col=nice.col,method="jitter",ylab="Normalised log2 expression",main="Csn1s2b")
```

An interactive version of the volcano plot above that includes the raw per sample values in a separate panel is possible via the `glXYPlot` function in the *Glimma* package.


```{r}
library(Glimma)
group2 <- group
levels(group2) <- c("basal.lactate","basal.preg","basal.virgin","lum.lactate", "lum.preg", "lum.virgin")
glXYPlot(x=fit.cont$coefficients[,1], y=fit.cont$lods[,1],
         xlab="logFC", ylab="B", main="B.PregVsLac",
         counts=y$counts, groups=group2, status=summa.fit[,1],
         anno=fit.cont$genes, id.column="ENTREZID", folder="volcano")
```


This function creates an html page (./volcano/XY-Plot.html) with a volcano plot on the left and a plot showing the log-CPM per sample for a selected gene on the right. A search bar is available to search for genes of interest.



## Genomic Locations

It might seem natural to add genomic locations to our annotation table, and possibly a bit odd that the `org.Mm.eg.db` package does not supply such mappings. In fact, there is a whole suite of package for performing such queries. 


- workflow to add genomic locations to the annotation table
- export tracks
- plot locations

```{r}
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
tx <- TxDb.Mmusculus.UCSC.mm10.knownGene
columns(tx)
```

```{r}
keys <- c("12992", "13358","20531")
select(tx, keys=keys,
       keytype = "GENEID",
       columns=c("EXONID","EXONSTART","EXONEND"))

```


```{r}
exo <- exonsBy(tx,"gene")
```


## Exporting tracks

It is also possible to save the results of a Bioconductor analysis in a browser to enable interactive analysis
and integration with other data types, or sharing with collaborators. For instance, we might want a
browser track to indicate where our differentially-expressed genes are located. We shall use the bed
format to display these locations.

At the moment, we have a GenomicFeatures object that represents every exon. However, we do not
need this level of granularity for the bed output

Select the names of the statistically significant genes from the edgeR output in the usual
manner.

```{r}
tt <- topTable(fit.cont,coef="B.PregVsLac",n=Inf)
sigGenes <- tt[tt$adj.P.Val < 0.05,]
sigGenes
```
Use the range function to obtain a single range for every gene. Get the genomic intervals that correspond to these DE genes.

```{r}
exoRanges <- unlist(range(exo))
sigRegions <- exoRanges[na.omit(match(sigGenes$ENTREZID, names(exoRanges)))]
sigRegions
```

Rather than just representing the genomic locations, the .bed format is also able to colour each range
according to some property of the analysis (e.g. direction and magnitude of change) to help highlight
particular regions of interest. A score can also be displayed when a particular region is clicked-on.
A useful propery of GenomicRanges is that we can attach metadata to each range using the mcols
function. The metadata can be supplied in the form of a data frame.

```{r}
mcols(sigRegions) <- sigGenes[match(names(sigRegions), sigGenes[,1]),]
sigRegions
```

```{r}
seqlevels(sigRegions)
sigRegions <- keepSeqlevels(sigRegions, paste0("chr", c(1:19,"X","Y")))
```

Create a score from the p-values that will displayed under each region, and colour scheme
for the regions based on the fold-change. For convenience, restrict the fold changes to be within the
region -3 to 3.

```{r}
sigRegions
Score <- -log10(sigRegions$adj.P.Val)
rbPal <-colorRampPalette(c("red", "blue"))
logfc <- pmax(sigRegions$logFC, -3)
logfc <- pmin(logfc , 3)
Col <- rbPal(10)[as.numeric(cut(logfc, breaks = 10))]
```

The colours and score can be saved in the GRanges object and score and itemRgb columns respectively
and will be used to construct the track when exporting. The rtracklayer function can be used to import
and export browsers tracks.

 Export the signifcant results from the DE analysis as a .bed track using rtracklayer. You
can load the resulting file in IGV, if you wish.
```{r}
mcols(sigRegions)$score <- Score
mcols(sigRegions)$itemRgb <- Col
library(rtracklayer)
export(sigRegions , con = "topHits.bed")
```

## Extracting Reads


```{r}
library(GenomicAlignments)
```

```{r}
generegion <- exo[["12992"]]
getwd()
bam <- readGAlignments(file="bam/MCL1.DG.bam",
                       param=ScanBamParam(which=generegion))
bam
```



### An aside - Acessing Genome Sequence

## Brief Introduction to ggplot2


```{r}
library(ggplot2)

top200 <- tt[1:200,]

ggplot(tt, aes(x = logFC, y=B)) + geom_point(alpha=0.4) + scale_color_manual(values=c("black","red")) + geom_text(data=top200, aes(x=logFC,y=B,label=SYMBOL),col="blue",alpha=0.4)

```


> ## Challenge {.challenge}
>
> Use ggplot2 to re-construct the MA- plot from above.
>

**Solution**

```{r,echo=FALSE}
# Soution
tt <- topTable(fit.cont,coef="B.PregVsLac",n=Inf)
ggplot(tt, aes(x = AveExpr, y=logFC)) + geom_point()

```


## Composing plots with ggbio

We will now take a brief look at one of the visualisation packages in Bioconductor that takes advantage
of the GenomicRanges and GenomicFeatures object-types. In this section we will show a worked
example of how to combine several types of genomic data on the same plot. The documentation for
ggbio is very extensive and contains lots of examples.

http://www.tengfei.name/ggbio/docs/

The Gviz package is another Bioconductor package that specialising in genomic visualisations, but we
will not explore this package in the course.

The Manhattan plot is a common way of visualising genome-wide results, and this is implemented as the
`plotGrandLinear` function. We have to supply a value to display on the y-axis, typically this is some
measure of significance. Changing this variable displayed on the y-axis is done by using the aes function,
which is inherited from ggplot2. The positioning of points on the x-axis is handled automatically by
ggbio, using the ranges information to get the genomic coordinates of the ranges of interest.

```{r}
library(ggbio)
plotGrandLinear(sigRegions , aes(y = score))
mcols(sigRegions)$Up <- logfc > 0
plotGrandLinear(sigRegions, aes(y = logFC, col = Up))
```

A useful function within ggbio is autoplot, which will construct an appropriate plot based on the
object-type of the input. For example, ggbio is able to plot the structure of genes according to a
particular model represented by a GenomicFeatures object.


```{r}
autoplot(tx, which=exo[["24117"]])
```

We can even plot the location of sequencing reads if they have been imported using readGAlignments
function (or similar).

```{r}
myreg <- flank(reduce(exo[["24117"]]), 1000, both = T)
bam <- readGAlignments(file="bam/MCL1.DG.bam",
                       param=ScanBamParam(which=myreg),use.names = TRUE)

autoplot(bam,which=myreg)
```

```{r}
autoplot(bam , stat = "coverage")
```
Like ggplot2, ggbio plots can be saved as objects that can later be modified, or combined together to
form more complicated plots. If saved in this way, the plot will only be displayed on a plotting device
when we query the object. This strategy is useful when we want to add a common element (such as
an ideogram) to a plot composition and donâ€™t want to repeat the code to generate the plot every time.

```{r}
#idPlot <- plotIdeogram(genome = "mm10")
#idPlot
geneMod <- autoplot(tx, which = myreg)
reads1 <- autoplot(bam, stat = "coverage")
tracks(geneMod ,reads1)
```


