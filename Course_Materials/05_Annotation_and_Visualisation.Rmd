---
title: "RNA-seq Analysis in R"
subtitle: "Annotation and Visualisation of RNA-seq results"
author: "Stephane Ballereau, Mark Dunning, Oscar Rueda, Ashley Sawle"
date: '`r format(Sys.time(), "Last modified: %d %b %Y")`'
output:
  html_notebook:
    toc: yes
  html_document:
    toc: yes
minutes: 300
layout: page
bibliography: ref.bib
editor_options: 
  chunk_output_type: console
---

```{r setup, echo=FALSE}
library(biomaRt)
library(tidyverse)
library(DESeq2)
```

Before starting this section, we will make sure we have all the relevant objects
from the Differential Expression analysis present.

```{r loadData}
load("Robjects/DE.Rdata")
```

# Overview

- Getting annotation
- Visualising DE results
- Retrieving gene models
- Exporting browser traecks


# Adding annotation to the DESeq2 results

We have a list of significantly differentially expressed genes, but the only
annotation we can see is the Ensembl Gene ID, which is not very informative. 

There are a number of ways to add annotation. One method is to do this using the
*org.Mm.eg.db* package. This package is one of several *organism-level* packages
which are re-built every 6 months. These packages are listed on the [annotation 
section](http://bioconductor.org/packages/release/BiocViews.html#___AnnotationData) 
of the Bioconductor, and are installed in the same way as regular Bioconductor 
packages. 

An alternative approach is to use `biomaRt`, an interface to the 
[BioMart](http://www.biomart.org/) resource. This is the method we will use 
today.

## Select BioMart database and dataset

The first step is to select the Biomart database we are going to access and 
which data set we are going to use.

```{r connect}
library(biomaRt)
# view the available databases
listMarts()
## set up connection to ensembl database
ensembl=useMart("ENSEMBL_MART_ENSEMBL")

# list the available datasets (species)
listDatasets(ensembl) %>% 
    filter(str_detect(description, "Mouse"))

# specify a data set to use
ensembl = useDataset("mmusculus_gene_ensembl", mart=ensembl)
```

## Query the database

Now we need to set up a query. For this we need to specify three things: 

(a) What type of information we are going to search the dataset on - called
**filters**. In our case this is Ensembl Gene IDs
(b) A vector if the **values** for our filter - the Ensembl Gene IDs from our DE 
results table.
(c) What columns (**attributes**) of the dataset we want returned.

Returning data from Biomart can take time, so it's always a good idea to test 
your query on a small list of values first to make sure it is what you want. 
We'll just use the first 10 gene id for now

```{r queryBioMart}

# check the available "filters" - things you can filter for
listFilters(ensembl) %>% 
    filter(str_detect(name, "ensembl"))
filterType <- "ensembl_gene_id"
filterValues <- rownames(resVvL)[1:1000]

# check the available "attributes" - things you can retreive
listAttributes(ensembl) %>% 
    head(20)
attributeNames <- c('ensembl_gene_id', 'entrezgene', 'external_gene_name')

# run the query
annot <- getBM(attributes=attributeNames, 
               filters = filterType, 
               values = filterValues, 
               mart = ensembl)
```


## One-to-many relationships

Let's inspect the annotation.

```{r inspectAnnot}
head(annot)
dim(annot) # why are there more than 1000 rows?
length(unique(annot$ensembl_gene_id)) # why are there less than 1000 Gene ids?

isDup <- duplicated(annot$ensembl_gene_id)
dup <- annot$ensembl_gene_id[isDup]
annot[annot$ensembl_gene_id%in%dup,]

annot %>% 
    group_by(ensembl_gene_id) %>% 
    mutate(count=length(entrezgene)) %>% 
    filter(count>1)
```

There are a couple of genes that have multiple entries in the retrieved 
annotation. This is becaues The one-to-many there are multiple Entrez IDs for a 
single Ensembl gene. These one-to-many relationships come up frequently in 
genomic databases, it is important to be aware of them and check when necessary. 

We will need to do a little work before adding the annotation to out results 
table. We could arbitrarily discard one of rows, or we could concatenate
the Entrez IDs so that we don't lose information. Let's do the latter.

```{r}
annot <- annot %>% 
    group_by(ensembl_gene_id) %>% 
    mutate(Entrez=str_c(entrezgene, collapse=";")) %>% 
    select(-entrezgene) %>% 
    distinct()

annot[annot$ensembl_gene_id%in%dup,]
dim(annot)
```

Now we have a unique Ensembl ID column, although we still had one missing 
gene id, and the returned gene id order may not be the same as out original 
table. 

> ### Challenge {.challenge}
> That was just 1000 genes. We need annotations for the entire results table.
> Also, there may be some other interesting columns in BioMart that we wish to
> retrieve.
> (a) Search the attributes and add in:
>    (i) The gene description 
>   (ii) The genomic position - chromosome, start, end, and strand (4 columns)
>  (iii) The gene biotype
> (b) Query BioMart using all of the genes in our results table (`resVvL`)
> (c) Deal with duplicate rows as above (hint: it's still just Entrez that 
> causes 1-many relations, but see if you can confirm this for yourself).

```{r solutionChallenge1}
# filterValues <- rownames(resVvL)

# check the available "attributes" - things you can retreive
# listAttributes(ensembl) %>%
#     head(20)
# attributeNames <- c(attributeNames,
#                     'description',
#                     'gene_biotype',
#                     'chromosome_name',
#                     'start_position',
#                     'end_position',
#                     'strand')
# 
# # run the query
# annot <- getBM(attributes=attributeNames,
#                filters = filterType,
#                values = filterValues,
#                mart = ensembl)
# 
# # deal with 1-many
# annotation_table <- annot %>%
#     group_by(ensembl_gene_id) %>%
#     mutate(Entrez=str_c(entrezgene, collapse=";")) %>%
#     dplyr::select(-entrezgene) %>%
#     distinct()
```

### Add annotation to the results table

We can now add the annotation to the results table and then save the results 
using the `write_csv` function, which writes the results out to a csv file.

```{r outputDEtable}
results.annotated <- as.data.frame(resVvL) %>% 
    rownames_to_column("ensembl_gene_id") %>% 
    left_join(annotation_table, "ensembl_gene_id")

write_tsv(results.annotated, "results/VirginVsLactating_Results_Annotated.txt")
```

# Visualisation

`DESeq2` provides a method called `lfcShrink` that shrinks log-Fold Change (LFC)
estimates towards zero using and empirical Bayes procedure. The reason for doing
this is that there is high variance in the LFC estimates when counts are low and
this results in lowly expressed genes appearing to be show greater differences 
between groups that highly expressed genes. The `lfcShrink` method compensates
for this and allows better visualisation and ranking of genes. We will use it
for our visualisations of the data.

```{r}
ddsObjVvLshrink <- lfcShrink(ddsObj, coef="Status_virgin_vs_lactate")
resTab <- ddsObjVvLshrink %>% 
    as.data.frame() %>% 
    rownames_to_column("ensembl_gene_id") %>% 
    left_join(annotation_table, "ensembl_gene_id") %>% 
    arrange(-padj)
```

## MA plots

MA plots are a common way to visualize the results of a differential analysis. 
We met them briefly towards the end of [Session 
2](02_Preprocessing_Data.nb.html). This plot shows the log-Fold Change for each 
gene against its average expression across all samples in the two conditions
being contrasted.

`DESeq2` has a handy function for plotting this...

```{r maPlotDESeq2}
plotMA(ddsObjVvLshrink, alpha=0.05)
```

...this is fine for a quick look, but it is not easy to make changes to the way
it looks or add things such as gene labels. Perhaps we would like to add labels
for the top 20 most significantly differentially expressed genes. Let's use 
ggplot2 instead.

```{r maPlot}

# what is the 20th lowest FDR (padj)
cutoff <- sort(resTab$padj)[20]

ggplot(resTab, aes(x = log2(baseMean), y=log2FoldChange, fill=padj < 0.05)) + 
    geom_point(pch=21, ) +
    scale_fill_manual(values=c("lightyellow","darkred", "black")) + 
    guides(fill = guide_legend(override.aes = list(alpha=1)))
```




## Volcano plot

Another common visualisation is the 
[*volcano plot*](https://en.wikipedia.org/wiki/Volcano_plot_(statistics)) which 
displays a measure of significance on the y-axis and fold-change on the x-axis. 

```{r volcanoPlot,fig.height=5,fig.width=10}

signif <- -log10(results.annotated$FDR)

plot(results.annotated$logFC, 
     signif,
     bg="black",
     pch=21,
     xlab="log2(Fold Change)")
points(results.annotated[detags,"logFC"],
       -log10(results.annotated[detags,"FDR"]),
       pch=21,
       bg="red")

```

### Strip chart for gene expression

Before following up on the DE genes with further lab work, a recommended *sanity check* is to have a look at the expression levels of the individual samples for the genes of interest. We can quickly look at grouped expression using `stripchart`. We can use the normalised log expression values in the  `dgeCounts` object (`dgeCounts$counts`).

```{r geneCountStripchart, fig.width=5, fig.height=5, fig.align="center"}
normCounts <- cpm(dgeObj, log = T)

# Let's look at the first gene in the topTable, Krt5, which has a rowname 110308
par(mar=c(8,4,2,2)) #adjust the plot margins the x-labels are visible - see ?par
stripchart(normCounts["110308",]~sampleinfo$Group,
           xlab="",
           ylab="log2(Counts)",
           vertical=TRUE,
           las=2,
           pch=21,
           col=1:6,
           cex=2)
```

### Interactive StripChart with Glimma

An interactive version of the volcano plot above that includes the raw per sample values in a separate panel is possible via the `glXYPlot` function in the *Glimma* package.


```{r}
library(Glimma)
group <- sampleinfo$Group
levels(group) <- c("basal.lactate","basal.preg","basal.virgin","lum.lactate", "lum.preg", "lum.virgin")
annot.mod <- annot
colnames(annot.mod)[1] <- "GeneID"
de <- as.numeric(results$FDR<=0.01)
glXYPlot(x=results$logFC, y=-log10(results$FDR),
         xlab="logFC", ylab="B", main="B.PregVsLac",
         counts=normCounts, groups=group, status=de,
         anno=annot.mod, id.column="ENTREZID", folder="volcano")
```

This function creates an html page (./volcano/XY-Plot.html) with a volcano plot on the left and a plot showing the log-CPM per sample for a selected gene on the right. A search bar is available to search for genes of interest.

## Retrieving Genomic Locations

It might seem natural to add genomic locations to our annotation table, and possibly a bit odd that the `org.Mm.eg.db` package does not supply such mappings. In fact, there is a whole suite of package for performing this, and more-advanced queries that relate to the location of genes. These are listed on the Bioconductor [annotation page](http://bioconductor.org/packages/release/BiocViews.html#___AnnotationData) and have the prefix `TxDb.`

The package we will be using is `TxDb.Mmusculus.UCSC.mm10.knownGene`. Packages are available for other organisms and genome builds. It is even possible to *build your own database* if one does not exist. See `vignette("GenomicFeatures")` for details

```{r installTxDb, eval=FALSE}
# source("http://www.bioconductor.org/biocLite.R")
## For mouse
# biocLite("TxDb.Mmusculus.UCSC.mm10.knownGene")
## For Humans
# biocLite("TxDb.Hsapiens.UCSC.hg19.knownGene")
```

We load the library in the usual fashion and create a new object to save some typing. As with the `org.` packages, we can query what columns are available with `columns`,

```{r loadTxDB, message=FALSE}
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
tx <- TxDb.Mmusculus.UCSC.mm10.knownGene
columns(tx)
```

The `select` function is used in the same manner as the `org.Mm.eg.db` packages. 


> ### Challenge 2 {.challenge}
>
> Use the TxDb.Mmusculus.UCSC.mm10.knownGene package to retrieve the exon coordinates for the genes `50916`, `110308`, `12293` 
>

```{r solutionChallenge2, echo=FALSE, warning=FALSE, message=FALSE}




```

## Overview of GenomicRanges

One of the real strengths of the `txdb..` packages is the ability of interface with `GenomicRanges`, which is the object type used throughout Bioconductor [to manipulate Genomic Intervals](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3738458/pdf/pcbi.1003118.pdf). 

These object types permit us to perform common operations on intervals such as overlapping and counting. We can define the chromosome, start and end position of each region (also strand too, but not shown here).

```{r simpleGR}
library(GenomicRanges)
simple_range <- GRanges(seqnames = "1", ranges = IRanges(start=1000, end=2000))
simple_range

```

We don't have to have all our ranges located on the same chromosome

```{r grForThreeGenes}
chrs <- c("chr13", "chr15", "chr5")
start <- c(73000000, 101000000, 15000000)
end <- c(74000000, 102000000, 16000000)

my_ranges <- GRanges(seqnames = rep(chrs, 3),
                     ranges = IRanges(start = rep(start, each = 3),
                                      end = rep(end, each = 3))
                     )
my_ranges
```

There are a number of useful functions for calculating properties of the data (such as *coverage* or sorting). Not so much for RNA-seq analysis, but `GenomicRanges` are used throughout Bioconductor for the analysis of NGS data. 

For instance, we can quickly identify overlapping regions between two `GenomicRanges`. 

```{r findOverlaps}
keys <- c("50916", "110308", "12293")
genePos <- select(tx,
                  keys = keys,
                  keytype = "GENEID",
                  columns = c("EXONCHROM", "EXONSTART", "EXONEND")
                  )

geneRanges <- GRanges(genePos$EXONCHROM, 
                      ranges = IRanges(genePos$EXONSTART, genePos$EXONEND), 
                      GENEID = genePos$GENEID)
geneRanges

findOverlaps(my_ranges, geneRanges)
```

However, we have to pay attention to the naming convention used for each object. 
`seqlevelsStyle` can help.

```{r seqNamingStyle}
seqlevelsStyle(geneRanges)
seqlevelsStyle(my_ranges)
seqlevelsStyle(simple_range)
```


### Exporting tracks

It is also possible to save the results of a Bioconductor analysis in a browser to enable interactive analysis and integration with other data types, or sharing with collaborators. For instance, we might want a browser track to indicate where our differentially-expressed genes are located. We shall use the `bed` format to display these locations. We will annotate the ranges with information from our analysis such as the fold-change and significance.

First we create a data frame for just the DE genes.
```{r tableOfDEGenes}
sigGenes <- results.annotated[detags,]
message("Number of significantly DE genes: ", nrow(sigGenes))
head(sigGenes)
```

### Create a genomic ranges object

Several convenience functions exist to retrieve the structure of every gene from
a given TxDb object in one list. The output of `exonsBy` is a list, where each 
item in the list is the exon co-ordinates of a particular gene, however, we do 
not need this level of granularity for the bed output, so we will collapse to a 
single region for each gene. 

First we use the `range` function to obtain a single range for every gene and 
tranform to a more convenient object with `unlist`.

```{r getGeneRanges}
exo <- exonsBy(tx, "gene")
exoRanges <- unlist(range(exo))
sigRegions <- exoRanges[na.omit(match(sigGenes$ENTREZID, names(exoRanges)))]
sigRegions
```

For visualisation purposes, we are going to restrict the data to genes that are located on chromosomes 1 to 19 and the sex chromosomes. This can be done with the `keepSeqLevels` function.

```{r trimSequences}
seqlevels(sigRegions)
sigRegions <- keepSeqlevels(sigRegions, 
                            value = paste0("chr", c(1:19,"X","Y")),
                            pruning.mode="tidy")
seqlevels(sigRegions)
```

### Add metadata to GRanges object

A useful propery of GenomicRanges is that we can attach *metadata* to each range using the `mcols`
function. The metadata can be supplied in the form of a data frame.

```{r addDEResults}
mcols(sigRegions) <- sigGenes[match(names(sigRegions), rownames(sigGenes)), ]
sigRegions
```

### Scores and colour on exported tracks

The `.bed` file format is commonly used to store genomic locations for display 
in genome browsers (e.g. the UCSC browser or IGV) as tracks. Rather than just 
representing the genomic locations, the `.bed` format is also able to colour 
each range according to some property of the analysis (e.g. direction and 
magnitude of change) to help highlight particular regions of interest. A score
can also be displayed when a particular region is clicked-on.

For the score we can use the $-log_{10}$ of the adjusted p-value and 
colour scheme for the regions based on the fold-change

`colorRampPalette` is a useful function in base R for constructing a palette between two extremes. **When choosing colour palettes, make sure they are colour blind friendly**. The red / green colour scheme traditionally-applied to microarrays is a ***bad*** choice.

We will also truncate the fold-changes to between -5 and 5 to and divide this range into 10 equal bins

```{r}
rbPal <- colorRampPalette(c("red", "blue"))
logfc <- pmax(sigRegions$logFC, -5)
logfc <- pmin(logfc , 5)

Cols <- rbPal(10)[as.numeric(cut(logfc, breaks = 10))]
```

The colours and score have to be saved in the GRanges object as `score` and `itemRgb` columns respectively, and will be used to construct the browser track. The rtracklayer package can be used to import and export browsers tracks.

Now we can export the signifcant results from the DE analysis as a `.bed` track using `rtracklayer`. You can load the resulting file in IGV, if you wish.

```{r}
mcols(sigRegions)$score <- -log10(sigRegions$FDR)
mcols(sigRegions)$itemRgb <- Cols
sigRegions

library(rtracklayer)
export(sigRegions , con = "topHits.bed")
```

# Additional Materials

## Extracting Reads

As we have been using counts as our starting point, we haven't investigated the aligned reads from our experiment, and how they are represented. As you may be aware, aligned reads are usually stored in a *bam* file that can be manipulated with open-source command-line tools such as [*samtools*](http://www.htslib.org/) and [*picard*](https://broadinstitute.github.io/picard/). Bioconductor provide a low-level interface to data/bam/sam files in the form of the `Rsamtools` package. The `GenomicAlignments` package can also be used to retrieve the reads mapping to a particular genomic region in an efficient manner.

```{r message=FALSE}
library(GenomicAlignments)
```

In the directory `bams_small` there should be `.bam` files for some of the samples in the example study. The workflow to produce these files is described in a [supplmentary page](../Supplementary_Materials/S1_Getting_raw_reads_from_SRA.nb.html) for the course. In brief, the raw reads (`fastq`) were downloaded from the Short Read Archive (SRA) and aligned with `hisat2`. Each bam file was named according to the file name in SRA, but we have renamed the files according to their name in the study. An index file (`.bai`) has been generated for each bam file. In order to reduce the size, the bam files used here only contain a subset of the reads that were aligned in the region chr15:101707000-101713000.


```{r}
list.files("data/bams_small/")
```

The `readGAlignments` function provides a simple interface to interrogate the aligned reads for a particular sample. It can also utilise the *index* file in order to retrieve only the reads that correspond to a specific region in an efficient manner. The output includes the genomic location of each aligned read and the CIGAR (**C**ompact **I**diosyncratic **G**apped **A**lignment **R**eport); where *M* denotes an match to the genome and *I*, *D* correspond to insertions and deletions.

```{r}
generegion <- exo[["110308"]]

my.reads <- readGAlignments(file="data/bams_small/MCL1.DG.small.bam",
                       param=ScanBamParam(which=generegion))
my.reads
```

It is possible to tweak the function to retrieve other potentially-useful information from the bam file, such as the mapping quality and flag.

```{r}
my.reads <- readGAlignments(file="data/bams_small//MCL1.DG.small.bam",
                       param=ScanBamParam(which=generegion,
                                          what=c("seq","mapq","flag")))
my.reads
```

The flag can represent useful QC information. e.g.

  + Read is unmapped
  + Read is paired / unpaired
  + Read failed QC
  + Read is a PCR duplicate (see later)

The combination of any of these properties is used to derive a numeric value, as illustrated in this useful [resource](https://broadinstitute.github.io/picard/explain-flags.html)

Particular attributes of the reads can be extracted and visualised

```{r}
hist(mcols(my.reads)$mapq, main="", xlab="MAPQ")
```

However, there are more-sophisticated visualisation options for aligned reads and range data. We will use the `ggbio` package, which first requires some discussion of the `ggplot2` plotting package.


## Brief Introduction to ggplot2

The [`ggplot2`](http://ggplot2.tidyverse.org/) package has emerged as an attractive alternative to the traditional plots provided by base R. A full overview of all capabilities of the package is available from the [cheatsheet](https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf).

A simple scatter plot, equivalent to `plotSmear` from before, can be generated as follows:-

```{r,fig.width=12,fig.height=5}
library(ggplot2)
ggplot(results, aes(x = logCPM, y=logFC)) + geom_point() 

```

In brief:-

- `results` is our data frame containing the variables we wish to plot
- `aes` creates a mpping between the variables in our data frame to the *aes*thetic proprties of the plot
    + the x-axis is mapped to `logCPM`, y-axis is mapped to `logFC`
- `geom_point` specifies the particular type of plot we want (in this case a scatter plot)
    + see [the cheatsheet](https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf) for other plot types

The real advantage of `ggplot2` is the ability to change the appearance of our plot by mapping other variables to aspects of the plot. For example, we could colour the points based on a p-value cut-off. The colours are automatically chosen by `ggplot2`, but we can specifiy particular values.

```{r,fig.width=12,fig.height=5}
ggplot(results, aes(x = logCPM, y=logFC, fill=FDR < 0.05)) + 
    geom_point(pch=21)

ggplot(results, aes(x = logCPM, y=logFC, fill=FDR < 0.05)) + 
    geom_point(alpha=0.4, pch=21) + 
    scale_fill_manual(values=c("yellow","red"))
```

The volcano plot can be constructed in a similar manner

```{r,fig.width=12, fig.height=5}
ggplot(results, aes(x = logFC, y=-log10(FDR))) + 
    geom_point(aes(fill=FDR < 0.05), pch=21, size=2)
```


## Composing plots with ggbio

We will now take a brief look at one of the visualisation packages in Bioconductor that takes advantage
of the GenomicRanges and GenomicFeatures object-types. In this section we will show a worked
example of how to combine several types of genomic data on the same plot. The documentation for
ggbio is very extensive and contains lots of examples.

http://www.tengfei.name/ggbio/docs/

The `Gviz` package is another Bioconductor package that specialising in genomic visualisations, but we
will not explore this package in the course.

The Manhattan plot is a common way of visualising genome-wide results, especially when one is concerned with the results of a GWAS study and identifying strongly-associated hits. 

The profile is supposed to resemble the Manhattan skyline with particular skyscrapers towering about the lower level buildings.

![](https://upload.wikimedia.org/wikipedia/commons/1/12/Manhattan_Plot.png)

This type of plot is implemented as the `plotGrandLinear` function. We have to supply a value to display on the y-axis using the `aes` function,
which is inherited from ggplot2. The positioning of points on the x-axis is handled automatically by
ggbio, using the ranges information to get the genomic coordinates of the ranges of interest.

To stop the plots from being too cluttered we will consider the top 200 genes only.

```{r,fig.width=12,fig.height=5}
library(ggbio)
top200 <- sigRegions[order(sigRegions$LR,decreasing = TRUE)[1:200]]

plotGrandLinear(top200 , aes(y = logFC))

```

`ggbio` has alternated the colours of the chromosomes. However, an appealing feature of `ggplot2` is the ability to map properties of your plot to variables present in your data. For example, we could create a variable to distinguish between up- and down-regulated genes. The variables used for aesthetic mapping must be present in the `mcols` section of your ranges object.

```{r,fig.width=12,fig.height=5}
mcols(top200)$UpRegulated <- mcols(top200)$logFC > 0

plotGrandLinear(top200, aes(y = logFC, col = UpRegulated))
```

`plotGrandLinear` is a special function in `ggbio` with preset options for the manhattan style of plot. More often, users will call the `autoplot` function and `ggbio` will choose the most appropriate layout. One such layout is the *karyogram*. 

```{r,fig.width=12,fig.height=5}

autoplot(top200,layout="karyogram",aes(color=UpRegulated,
                                       fill=UpRegulated))

```



`ggbio` is also able to plot the structure of genes according to a particular model represented by a `GenomicFeatures` object, such as the object we created earlier with the exon coordinates for each gene in the mm10 genome.


```{r}
autoplot(tx, which=exo[["110308"]])
```

We can even plot the location of sequencing reads if they have been imported using readGAlignments function (or similar).

```{r}
myreg <- flank(reduce(exo[["110308"]]), 1000, both = T)

bam <- readGappedReads(file="data/bams_small/MCL1.DG.small.bam",
                       param=ScanBamParam(which=myreg),use.names = TRUE)

autoplot(bam, geom = "rect") + 
    xlim(GRanges("chr15", IRanges(101707000, 101713000)))
```

Like ggplot2, ggbio plots can be saved as objects that can later be modified, or combined together to
form more complicated plots. If saved in this way, the plot will only be displayed on a plotting device
when we query the object. This strategy is useful when we want to add a common element (such as
an ideogram) to a plot composition and donâ€™t want to repeat the code to generate the plot every time.

```{r}
#idPlot <- plotIdeogram(genome = "mm10",subchr = "chr1")
#idPlot
geneMod <- autoplot(tx, which = myreg)
reads.MCL1.DG <- autoplot(bam, stat = "coverage")  + 
    xlim(GRanges("chr15", IRanges(101707000, 101713000))) +
    labs(title="MCL1.DG")
tracks(mm10=geneMod, MCL1.DG=reads.MCL1.DG ) 
```

> ## Challenge {.challenge}
>
> Create tracks to compare the coverage of the gene Krt5 for the samples MCL1.DG, MCL1.DH, MCL1.LA and MCL1.LB
>

```{r,echo=FALSE,fig.height=5,fig.width=10}


```

